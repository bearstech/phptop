#!/usr/bin/perl

# phptop - Analyse quickly system ressource usage across many PHP queries
# Copyright (C) 2009 Bearstech - http://bearstech.com/
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# Depends on LWP aka libwww-perl (what else ?)

use strict;
use warnings;
use Getopt::Long qw(:config no_auto_abbrev no_ignore_case bundling);
use HTTP::Date;
use POSIX;

my $package_name    = 'phptop';
my $package_version = '0.3.1';
my $package_owner   = 'Copyright (C) 2009 Bearstech - http://bearstech.com/';
my $package_url     = 'http://forge.bearstech.com/trac/wiki/PhpTop';

# Options
my $help;
my $version;
my @log;
my $full_query;
my $count = 10;
my $sortkeys = 'hit';
my $span = 10;
my $path_only;

# Globals
my @keys = qw/hit time user sys mem mem_max inc inc_max/;
my %stat;
my $now   = time();
my $hits  = 0;
my $bogus = 0;


sub print_short_help {
    print STDERR <<EOF;
Usage: $package_name [options]

Try '$package_name --help' for more information.
EOF
    exit 2;
}

sub print_help {
    print STDERR <<EOF;
Usage: $package_name [options]

Options:
  -c, --count N        Limit output to top N URIs (default is $count)
  -f, --full-query     Consider full URI with CGI parameters
  -h, --help           Display this information
  -l, --log path       Logfiles to parse, you may use several -l and wildcards
  -p, --path-only      Only print path, skip http://host
  -s, --sort key,...   Sort key: hit, time, user, sys, mem or inc (default is $sortkeys)
  -t, --time N         Consider log events from now back to N minutes (default is $span)
  -v, --version        Display version number and copyright info

Columns explanation:
  Hit       Number of queries
  Time      Total wall clock time (in seconds)
  User      Total CPU time (in seconds)
  Sys       Total system time (in seconds)
  Mem/hit   Average allocated memory per query (MB/hit)
  Mem_max   Maximum allocated memory across queries (MB)
  Inc/hit   Average included files per query
  Inc_max   Maximum included files across queries
EOF
    exit 0
}

sub print_version {
    print "$package_name $package_version\n";
    exit 0;
}

sub parse_log {
    my $logfile = shift;

    my $lh;
    if (!open($lh, "<$logfile")) {
        warn "$logfile: $!";
        return 0;
    }

  LINE:
    while (<$lh>) {
        chomp;
        next if not /\bphptop ([^ ]+) (.*)/;
        my ($uri, $pairs) = ($1, $2);

        # Only keep records within expected time span. If a time stamp is not found or
        # cannot be parsed, we still process the item.
        if (/^\[(.*?)\]/) {
            my $stamp = str2time($1);
            next if defined $stamp && ($now - $stamp) > $span * 60;
        }

        $pairs =~ s/, referer.*//;     # Apache may append a referer in error.log, ignore
        $pairs =~ s/(\d),(\d)/$1.$2/g; # Be independent of the PHP locale, normalize on dot decimal separator
        my @kv = split(/ /, $pairs);
        next if @kv < 5;               # Protect against bogus/wrapped phptop records, count pairs

        # Fix URIs (depending on options)
        $uri =~ s/index\.php\/?//;  # / == /index.php (99.9% of the time)
        $uri =~ s/\?.*// if not defined $full_query;
        $uri =~ s/^https?:\/\/[^\/]+// if defined $path_only;

        # For each 'key:<numeric val>' sum the numeric value per URI
        foreach (@kv) {
            my ($key, $val) = split(/:/, $_);

            # If we have a bogus key/value pair, zap the whole record
            if ($key eq '' or not defined $val or not $val =~ /^[0-9.]+$/) {
                delete $stat{$uri};
                $bogus++;
                next LINE;
            }

            $stat{$uri}{$key} += $val;

            # Compute max for some values (mem, inc)
            if ($key eq 'mem') {
                $stat{$uri}{'mem_max'} = $val if ($stat{$uri}{'mem_max'} || 0) < $val;
            }
            elsif ($key eq 'inc') {
                $stat{$uri}{'inc_max'} = $val if ($stat{$uri}{'inc_max'} || 0) < $val;
            }
        }

        $stat{$uri}{'hit'}++;
        $hits++;
    }

    close($lh);
    1;
}

sub fix_stat {
    # Convert 'mem'  and 'inc' values from total to 'per hit', more useful and meaningful
    while (my ($url, $i) = each %stat) {
        $i->{'mem_max'} /= 2**20;            # Also scale memory values from bytes to MB
        $i->{'mem'} /= $i->{'hit'} * 2**20;  # Idem
        $i->{'inc'} /= $i->{'hit'};
    }
}

sub text_report {
    my $sortkey = shift;

    # Sort queries according to $sortkey (they are all numeric)
    my @sorted = sort { $stat{$b}{$sortkey} - $stat{$a}{$sortkey} } keys %stat;
    
    # Compute URI column width
    my $width = 0;
    my $n = 0;
    foreach (@sorted) {
        last if $n++ >= $count;
        my $w = length($_);
        $width = $w if $w > $width;
    }
    
    my %total;
    my @tkeys = qw/hit time user sys/;
    $n = 0;
    
    printf("%-${width}s %s\n", "", join(' ', map { sprintf('%8s', ucfirst($_ =~ /^(mem|inc)$/ ? "$_/hit" : $_)) } @keys));
    foreach (@sorted) {
        my $s = $stat{$_};
        $total{$_} += $s->{$_} foreach @tkeys;
        next if $n++ >= $count; # Continue to loop and only sum totals if $count records have been displayed
    
        printf("%-${width}s", $_);
        printf($_ =~ m/hit|inc/ ? ' %8d' : ' %8.1f', $s->{$_}) foreach @keys;
        print "\n";
    }
    printf("\n%-${width}s", 'Total');
    printf($_ =~ m/hit/ ? ' %8d' : ' %8.1f', $total{$_}) foreach @tkeys;
    print "\n";
}


GetOptions(
    'c|count=i'      => \$count,
    'f|full-query'   => \$full_query,
    'h|help'         => \$help,
    'l|log=s'        => \@log,
    'p|path'         => \$path_only,
    's|sort=s'       => \$sortkeys,
    't|time=s'       => \$span,
    'v|version'      => \$version,
)
or print_short_help();

print_help() if $help;
print_version() if $version;

POSIX::setlocale(POSIX::LC_ALL, 'C'); # Use . as decimal separator

my @logfiles;
push(@log, '/var/log/apache2/error*log', '/var/log/apache2/*/error*log') if !@log;
map { push(@logfiles, glob($_)) } @log;

my $parsed = 0;
$parsed += parse_log($_) foreach @logfiles;

if ($parsed == 0) {
    print STDERR "Error: no log files found/processed. Tried: ".join(", ", @log)."\n";
    exit 2;
}
if ($hits == 0) {
    print STDERR "No phptop records found.\n";
    exit 0;
}
if ($bogus >= $hits * .05) {
    print STDERR "Warning: you have more than 5% malformed records ($bogus out of $hits).\n";
}

fix_stat();

my @sortkeyl = split(/,/, $sortkeys);

my $reportnb = 0;
foreach (@sortkeyl) {
  print "--\n" if $reportnb++;
  text_report($_);
}
